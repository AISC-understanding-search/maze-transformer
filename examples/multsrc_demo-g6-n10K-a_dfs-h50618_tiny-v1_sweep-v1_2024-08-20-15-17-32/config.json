{
	"__format__": "ConfigHolder(SerializableDataclass)",
	"dataset_cfg": {
		"__format__": "MazeDatasetConfig(SerializableDataclass)",
		"name": "demo",
		"seq_len_min": 1,
		"seq_len_max": 512,
		"seed": 42,
		"applied_filters": [],
		"grid_n": 6,
		"n_mazes": 10000,
		"maze_ctor": {
			"__name__": "gen_dfs",
			"__module__": "maze_dataset.generation.generators",
			"__doc__": [
				"generate a lattice maze using depth first search, iterative",
				"",
				"        # Arguments",
				"        - `grid_shape: Coord`: the shape of the grid",
				"        - `lattice_dim: int`: the dimension of the lattice",
				"          (default: `2`)",
				"        - `accessible_cells: int | float |None`: the number of accessible cells in the maze. If `None`, defaults to the total number of cells in the grid. if a float, asserts it is <= 1 and treats it as a proportion of **total cells**",
				"            (default: `None`)",
				"        - `max_tree_depth: int | float | None`: the maximum depth of the tree. If `None`, defaults to `2 * accessible_cells`. if a float, asserts it is <= 1 and treats it as a proportion of the **sum of the grid shape**",
				"            (default: `None`)",
				"        - `do_forks: bool`: whether to allow forks in the maze. If `False`, the maze will be have no forks and will be a simple hallway.",
				"        - `start_coord: Coord | None`: the starting coordinate of the generation algorithm. If `None`, defaults to a random coordinate.",
				"",
				"        # algorithm",
				"        1. Choose the initial cell, mark it as visited and push it to the stack",
				"        2. While the stack is not empty",
				"                1. Pop a cell from the stack and make it a current cell",
				"                2. If the current cell has any neighbours which have not been visited",
				"                        1. Push the current cell to the stack",
				"                        2. Choose one of the unvisited neighbours",
				"                        3. Remove the wall between the current cell and the chosen cell",
				"                        4. Mark the chosen cell as visited and push it to the stack",
				"        "
			],
			"source_code": [
				"    @staticmethod",
				"    def gen_dfs(",
				"        grid_shape: Coord,",
				"        lattice_dim: int = 2,",
				"        accessible_cells: int | float | None = None,",
				"        max_tree_depth: int | float | None = None,",
				"        do_forks: bool = True,",
				"        randomized_stack: bool = False,",
				"        start_coord: Coord | None = None,",
				"    ) -> LatticeMaze:",
				"        \"\"\"generate a lattice maze using depth first search, iterative",
				"",
				"        # Arguments",
				"        - `grid_shape: Coord`: the shape of the grid",
				"        - `lattice_dim: int`: the dimension of the lattice",
				"          (default: `2`)",
				"        - `accessible_cells: int | float |None`: the number of accessible cells in the maze. If `None`, defaults to the total number of cells in the grid. if a float, asserts it is <= 1 and treats it as a proportion of **total cells**",
				"            (default: `None`)",
				"        - `max_tree_depth: int | float | None`: the maximum depth of the tree. If `None`, defaults to `2 * accessible_cells`. if a float, asserts it is <= 1 and treats it as a proportion of the **sum of the grid shape**",
				"            (default: `None`)",
				"        - `do_forks: bool`: whether to allow forks in the maze. If `False`, the maze will be have no forks and will be a simple hallway.",
				"        - `start_coord: Coord | None`: the starting coordinate of the generation algorithm. If `None`, defaults to a random coordinate.",
				"",
				"        # algorithm",
				"        1. Choose the initial cell, mark it as visited and push it to the stack",
				"        2. While the stack is not empty",
				"                1. Pop a cell from the stack and make it a current cell",
				"                2. If the current cell has any neighbours which have not been visited",
				"                        1. Push the current cell to the stack",
				"                        2. Choose one of the unvisited neighbours",
				"                        3. Remove the wall between the current cell and the chosen cell",
				"                        4. Mark the chosen cell as visited and push it to the stack",
				"        \"\"\"",
				"",
				"        # Default values if no constraints have been passed",
				"        grid_shape: Coord = np.array(grid_shape)",
				"        n_total_cells: int = int(np.prod(grid_shape))",
				"",
				"        n_accessible_cells: int",
				"        if accessible_cells is None:",
				"            n_accessible_cells = n_total_cells",
				"        elif isinstance(accessible_cells, float):",
				"            assert (",
				"                accessible_cells <= 1",
				"            ), f\"accessible_cells must be an int (count) or a float in the range [0, 1] (proportion), got {accessible_cells}\"",
				"",
				"            n_accessible_cells = int(accessible_cells * n_total_cells)",
				"        else:",
				"            assert isinstance(accessible_cells, int)",
				"            n_accessible_cells = accessible_cells",
				"",
				"        if max_tree_depth is None:",
				"            max_tree_depth = (",
				"                2 * n_total_cells",
				"            )  # We define max tree depth counting from the start coord in two directions. Therefore we divide by two in the if clause for neighboring sites later and multiply by two here.",
				"        elif isinstance(max_tree_depth, float):",
				"            assert (",
				"                max_tree_depth <= 1",
				"            ), f\"max_tree_depth must be an int (count) or a float in the range [0, 1] (proportion), got {max_tree_depth}\"",
				"",
				"            max_tree_depth = int(max_tree_depth * np.sum(grid_shape))",
				"",
				"        # choose a random start coord",
				"        start_coord = _random_start_coord(grid_shape, start_coord)",
				"",
				"        # initialize the maze with no connections",
				"        connection_list: ConnectionList = np.zeros(",
				"            (lattice_dim, grid_shape[0], grid_shape[1]), dtype=np.bool_",
				"        )",
				"",
				"        # initialize the stack with the target coord",
				"        visited_cells: set[tuple[int, int]] = set()",
				"        visited_cells.add(tuple(start_coord))  # this wasnt a bug after all lol",
				"        stack: list[Coord] = [start_coord]",
				"",
				"        # initialize tree_depth_counter",
				"        current_tree_depth: int = 1",
				"",
				"        # loop until the stack is empty or n_connected_cells is reached",
				"        while stack and (len(visited_cells) < n_accessible_cells):",
				"            # get the current coord from the stack",
				"            current_coord: Coord",
				"            if randomized_stack:",
				"                current_coord = stack.pop(random.randint(0, len(stack) - 1))",
				"            else:",
				"                current_coord = stack.pop()",
				"",
				"            # filter neighbors by being within grid bounds and being unvisited",
				"            unvisited_neighbors_deltas: list[tuple[Coord, Coord]] = [",
				"                (neighbor, delta)",
				"                for neighbor, delta in zip(",
				"                    current_coord + NEIGHBORS_MASK, NEIGHBORS_MASK",
				"                )",
				"                if (",
				"                    (tuple(neighbor) not in visited_cells)",
				"                    and (0 <= neighbor[0] < grid_shape[0])",
				"                    and (0 <= neighbor[1] < grid_shape[1])",
				"                )",
				"            ]",
				"",
				"            # don't continue if max_tree_depth/2 is already reached (divide by 2 because we can branch to multiple directions)",
				"            if unvisited_neighbors_deltas and (",
				"                current_tree_depth <= max_tree_depth / 2",
				"            ):",
				"                # if we want a maze without forks, simply don't add the current coord back to the stack",
				"                if do_forks and (len(unvisited_neighbors_deltas) > 1):",
				"                    stack.append(current_coord)",
				"",
				"                # choose one of the unvisited neighbors",
				"                chosen_neighbor, delta = random.choice(unvisited_neighbors_deltas)",
				"",
				"                # add connection",
				"                dim: int = np.argmax(np.abs(delta))",
				"                # if positive, down/right from current coord",
				"                # if negative, up/left from current coord (down/right from neighbor)",
				"                clist_node: Coord = (",
				"                    current_coord if (delta.sum() > 0) else chosen_neighbor",
				"                )",
				"                connection_list[dim, clist_node[0], clist_node[1]] = True",
				"",
				"                # add to visited cells and stack",
				"                visited_cells.add(tuple(chosen_neighbor))",
				"                stack.append(chosen_neighbor)",
				"",
				"                # Update current tree depth",
				"                current_tree_depth += 1",
				"            else:",
				"                current_tree_depth -= 1",
				"",
				"        output = LatticeMaze(",
				"            connection_list=connection_list,",
				"            generation_meta=dict(",
				"                func_name=\"gen_dfs\",",
				"                grid_shape=grid_shape,",
				"                start_coord=start_coord,",
				"                n_accessible_cells=int(n_accessible_cells),",
				"                max_tree_depth=int(max_tree_depth),",
				"                # oh my god this took so long to track down. its almost 5am and I've spent like 2 hours on this bug",
				"                # it was checking that len(visited_cells) == n_accessible_cells, but this means that the maze is",
				"                # treated as fully connected even when it is most certainly not, causing solving the maze to break",
				"                fully_connected=bool(len(visited_cells) == n_total_cells),",
				"                visited_cells={tuple(int(x) for x in coord) for coord in visited_cells},",
				"            ),",
				"        )",
				"",
				"        return output"
			]
		},
		"maze_ctor_kwargs": {},
		"endpoint_kwargs": {},
		"grid_shape": [
			6,
			6
		]
	},
	"model_cfg": {
		"__format__": "BaseGPTConfig(SerializableDataclass)",
		"name": "tiny-v1",
		"act_fn": "gelu",
		"d_model": 32,
		"d_head": 16,
		"n_layers": 4,
		"positional_embedding_type": "standard",
		"weight_processing": {
			"are_layernorms_folded": false,
			"are_weights_processed": false
		},
		"n_heads": 2
	},
	"train_cfg": {
		"__format__": "TrainConfig(SerializableDataclass)",
		"name": "sweep-v1",
		"evals_max_new_tokens": 8,
		"validation_dataset_cfg": 50,
		"optimizer": "AdamW",
		"optimizer_kwargs": {
			"lr": 0.0001
		},
		"batch_size": 64,
		"dataloader_cfg": {
			"shuffle": true,
			"num_workers": 8,
			"persistent_workers": true,
			"drop_last": true
		},
		"intervals": null,
		"intervals_count": null
	},
	"name": "multsrc_demo-g6-n10K-a_dfs-h50618_tiny-v1_sweep-v1",
	"pretrainedtokenizer_kwargs": null,
	"maze_tokenizer": {
		"__format__": "MazeTokenizerModular(SerializableDataclass)",
		"prompt_sequencer": {
			"__format__": "AOTP(SerializableDataclass)",
			"coord_tokenizer": {
				"__format__": "UT(SerializableDataclass)",
				"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.CoordTokenizers.UT'>"
			},
			"adj_list_tokenizer": {
				"__format__": "AdjListCoord(SerializableDataclass)",
				"pre": false,
				"post": true,
				"shuffle_d0": true,
				"edge_grouping": {
					"__format__": "Ungrouped(SerializableDataclass)",
					"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.EdgeGroupings.Ungrouped'>",
					"connection_token_ordinal": 1
				},
				"edge_subset": {
					"__format__": "ConnectionEdges(SerializableDataclass)",
					"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.EdgeSubsets.ConnectionEdges'>",
					"walls": false
				},
				"edge_permuter": {
					"__format__": "RandomCoords(SerializableDataclass)",
					"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.EdgePermuters.RandomCoords'>"
				},
				"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.AdjListTokenizers.AdjListCoord'>"
			},
			"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.PromptSequencers.AOTP'>",
			"target_tokenizer": {
				"__format__": "Unlabeled(SerializableDataclass)",
				"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.TargetTokenizers.Unlabeled'>",
				"post": false
			},
			"path_tokenizer": {
				"__format__": "StepSequence(SerializableDataclass)",
				"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.PathTokenizers.StepSequence'>",
				"step_size": {
					"__format__": "Singles(SerializableDataclass)",
					"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.StepSizes.Singles'>"
				},
				"step_tokenizers": [
					{
						"__format__": "Coord(SerializableDataclass)",
						"_type": "<class 'maze_dataset.tokenization.maze_tokenizer.StepTokenizers.Coord'>"
					}
				],
				"pre": false,
				"intra": false,
				"post": false
			}
		},
		"tokenizer_element_tree_concrete": "MazeTokenizerModular\n\tAOTP\n\t\tUT\n\t\tAdjListCoord\n\t\t\tUngrouped\n\t\t\tConnectionEdges\n\t\t\tRandomCoords\n\t\tUnlabeled\n\t\tStepSequence\n\t\t\tSingles\n\t\t\tCoord\n",
		"name": "MazeTokenizerModular-AOTP(UT(), AdjListCoord(pre=F, post=T, shuffle_d0=T, Ungrouped(connection_token_ordinal=1), ConnectionEdges(walls=F), RandomCoords()), Unlabeled(post=F), StepSequence(Singles(), step_tokenizers=(Coord(), ), pre=F, intra=F, post=F))"
	},
	"_tokenizer": "None"
}