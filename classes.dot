digraph "classes" {
rankdir=BT
charset="utf-8"
"maze_transformer.evaluation.pathdist.ArrMazeEvalFuncs" [color="black", fontcolor="black", label=<{ArrMazeEvalFuncs|<br ALIGN="LEFT"/>|fraction_connections_adjacent(): float<br ALIGN="LEFT"/>fraction_connections_adjacent_lattice(): float<br ALIGN="LEFT"/>num_connections_adjacent(): float<br ALIGN="LEFT"/>num_connections_adjacent_lattice(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.training.config.BaseGPTConfig" [color="black", fontcolor="black", label=<{BaseGPTConfig|act_fn : str<br ALIGN="LEFT"/>d_head : int<br ALIGN="LEFT"/>d_model : int<br ALIGN="LEFT"/>n_layers : int<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"maze_transformer.training.config.ConfigHolder" [color="black", fontcolor="black", label=<{ConfigHolder|dataset_cfg : GPTDatasetConfig \| MazeDatasetConfig<br ALIGN="LEFT"/>model_cfg<br ALIGN="LEFT"/>tokenizer : PreTrainedTokenizer<br ALIGN="LEFT"/>tokenizer : PreTrainedTokenizer \| None<br ALIGN="LEFT"/>train_cfg<br ALIGN="LEFT"/>|create_model(): HookedTransformer<br ALIGN="LEFT"/>load(serialized: Dict[str, Dict[Any, Any]])<br ALIGN="LEFT"/>serialize()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.training.mazedataset.MazeDataset.DISK_SAVE_FILES" [color="black", fontcolor="black", label=<{DISK_SAVE_FILES|cfg : str<br ALIGN="LEFT"/>tokenized : str<br ALIGN="LEFT"/>tokens : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"maze_transformer.training.dataset.GPTDataset" [color="black", fontcolor="black", label=<{GPTDataset|<br ALIGN="LEFT"/>|<I>config_save_name</I>(): str<br ALIGN="LEFT"/><I>get_all_lengths</I>(): list[int]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.training.dataset.GPTDatasetConfig" [color="black", fontcolor="black", label=<{GPTDatasetConfig|device<br ALIGN="LEFT"/>dtype : torch.dtype \| np.dtype<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>padding_token_idx<br ALIGN="LEFT"/>seq_len_max : int<br ALIGN="LEFT"/>seq_len_min : int<br ALIGN="LEFT"/>token_arr<br ALIGN="LEFT"/>tokenizer_map<br ALIGN="LEFT"/>|<I>load</I>(data: dict): 'DatasetConfig'<br ALIGN="LEFT"/><I>serialize</I>(): dict<br ALIGN="LEFT"/>tokenize_seq(seq: list[str]): ATensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.training.dataset.IndexedArray" [color="black", fontcolor="black", label=<{IndexedArray|arr : _BaseArray, ATensor<br ALIGN="LEFT"/>idxs : _BaseArray, ATensor<br ALIGN="LEFT"/>|from_sequences(data: list[ATensor['tokens']]): 'IndexedArray'<br ALIGN="LEFT"/>get_all_lengths(): ATensor<br ALIGN="LEFT"/>get_len(idx: int): int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.generation.latticemaze.LatticeMaze" [color="black", fontcolor="black", label=<{LatticeMaze|connection_list : NDArray['lattice_dim x y', bool]<br ALIGN="LEFT"/>generation_meta : Optional[dict \| None]<br ALIGN="LEFT"/>grid_shape<br ALIGN="LEFT"/>lattice_dim : int<br ALIGN="LEFT"/>n_connections<br ALIGN="LEFT"/>|as_adj_list(shuffle_d0: bool, shuffle_d1: bool): NDArray['conn start_end coord', np.int8]<br ALIGN="LEFT"/>as_img(): NDArray['x y', bool]<br ALIGN="LEFT"/>find_shortest_path(c_start: CoordTup, c_end: CoordTup): list[Coord]<br ALIGN="LEFT"/>from_adjlist(adjlist: NDArray['conn start_end coord', np.int8]): 'LatticeMaze'<br ALIGN="LEFT"/>from_tokens(maze_tokens: list[str]): 'LatticeMaze'<br ALIGN="LEFT"/>generate_random_path(): list[Coord]<br ALIGN="LEFT"/>get_coord_neighbors(c: Coord): CoordArray<br ALIGN="LEFT"/>get_nodes(): list[Coord]<br ALIGN="LEFT"/>heuristic(a: CoordTup, b: CoordTup): float<br ALIGN="LEFT"/>nodes_connected(): bool<br ALIGN="LEFT"/>points_transform_to_img(points: CoordArray): CoordArray<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.generation.generators.LatticeMazeGenerators" [color="black", fontcolor="black", label=<{LatticeMazeGenerators|<br ALIGN="LEFT"/>|gen_dfs(grid_shape: Coord, start_coord: Coord | None, lattice_dim: int): 'LatticeMaze'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.training.mazedataset.MazeDataset" [color="black", fontcolor="black", label=<{MazeDataset|cfg<br ALIGN="LEFT"/>mazes_array : Optional[IndexedArray \| None]<br ALIGN="LEFT"/>mazes_objs : Optional[list[MazeTokenizer] \| None]<br ALIGN="LEFT"/>mazes_tokens : Optional[list[list[str]] \| None], list<br ALIGN="LEFT"/>|config_save_name(): str<br ALIGN="LEFT"/>disk_load(path_base: str, do_config: bool, do_obj: bool, do_tokens: bool, do_tokenized: bool): 'MazeDataset'<br ALIGN="LEFT"/>disk_save(path_base: str, do_config: bool, do_obj: bool, do_tokens: bool, do_tokenized: bool): None<br ALIGN="LEFT"/>gen_default(cfg: MazeDatasetConfig): 'MazeDataset'<br ALIGN="LEFT"/>get_all_lengths(): list[int]<br ALIGN="LEFT"/>serialize_config(): JSONitem<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.training.mazedataset.MazeDatasetConfig" [color="black", fontcolor="black", label=<{MazeDatasetConfig|grid_n : int<br ALIGN="LEFT"/>grid_shape<br ALIGN="LEFT"/>maze_ctor : Callable<br ALIGN="LEFT"/>n_mazes : int<br ALIGN="LEFT"/>n_tokens<br ALIGN="LEFT"/>node_token_map<br ALIGN="LEFT"/>padding_token_idx<br ALIGN="LEFT"/>token_arr<br ALIGN="LEFT"/>token_node_map<br ALIGN="LEFT"/>|load(data: JSONitem): 'MazeDatasetConfig'<br ALIGN="LEFT"/>serialize(): JSONitem<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.evaluation.pathdist.MazeEvalFuncs" [color="black", fontcolor="black", label=<{MazeEvalFuncs|<br ALIGN="LEFT"/>|node_overlap(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.training.tokenizer.MazeTokenizer" [color="black", fontcolor="black", label=<{MazeTokenizer|maze<br ALIGN="LEFT"/>metadata : dict<br ALIGN="LEFT"/>pos_end<br ALIGN="LEFT"/>pos_start<br ALIGN="LEFT"/>solution<br ALIGN="LEFT"/>|as_tokens(node_token_map: dict[CoordTup, str], solution: bool): list[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"maze_transformer.evaluation.plot_maze.PathFormat" [color="black", fontcolor="black", label=<{PathFormat|color : Optional[str \| None]<br ALIGN="LEFT"/>fmt : Optional[str \| None]<br ALIGN="LEFT"/>label : Optional[str \| None]<br ALIGN="LEFT"/>path : NDArray, _BaseArray<br ALIGN="LEFT"/>quiver_kwargs : dict \| None<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"maze_transformer.training.training.TRAIN_SAVE_FILES" [color="black", fontcolor="black", label=<{TRAIN_SAVE_FILES|checkpoints : str<br ALIGN="LEFT"/>config_holder : str<br ALIGN="LEFT"/>data_cfg : str<br ALIGN="LEFT"/>log : str<br ALIGN="LEFT"/>model_checkpt : Callable[[int], str]<br ALIGN="LEFT"/>model_final : str<br ALIGN="LEFT"/>train_cfg : str<br ALIGN="LEFT"/>train_dir_format : Callable[[GPTDatasetConfig, TrainConfig], str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"maze_transformer.training.config.TrainConfig" [color="black", fontcolor="black", label=<{TrainConfig|batch_size : int<br ALIGN="LEFT"/>checkpoint_interval : int<br ALIGN="LEFT"/>dataloader_cfg : dict<br ALIGN="LEFT"/>epochs : int<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>optimizer : Type[torch.optim.Optimizer]<br ALIGN="LEFT"/>optimizer_kwargs : dict[str, Any]<br ALIGN="LEFT"/>print_loss_interval : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"maze_transformer.training.mazedataset.MazeDataset" -> "maze_transformer.training.dataset.GPTDataset" [arrowhead="empty", arrowtail="none"];
"maze_transformer.training.mazedataset.MazeDatasetConfig" -> "maze_transformer.training.dataset.GPTDatasetConfig" [arrowhead="empty", arrowtail="none"];
"maze_transformer.generation.latticemaze.LatticeMaze" -> "maze_transformer.training.tokenizer.MazeTokenizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="maze", style="solid"];
"maze_transformer.training.config.BaseGPTConfig" -> "maze_transformer.training.config.ConfigHolder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model_cfg", style="solid"];
"maze_transformer.training.config.TrainConfig" -> "maze_transformer.training.config.ConfigHolder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="train_cfg", style="solid"];
"maze_transformer.training.dataset.IndexedArray" -> "maze_transformer.training.mazedataset.MazeDataset" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="mazes_array", style="solid"];
"maze_transformer.training.mazedataset.MazeDatasetConfig" -> "maze_transformer.training.mazedataset.MazeDataset" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="cfg", style="solid"];
}
